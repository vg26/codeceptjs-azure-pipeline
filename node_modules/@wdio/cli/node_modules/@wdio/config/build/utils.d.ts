import type { Capabilities, Options } from '@wdio/types';
import { RegisterOptions } from 'ts-node';
declare const REGION_MAPPING: {
    us: string;
    eu: string;
    'eu-central-1': string;
    'us-east-1': string;
};
export declare const validObjectOrArray: (object: any) => object is object | any[];
export declare function getSauceEndpoint(region: keyof typeof REGION_MAPPING, { isRDC, isVisual }?: {
    isRDC?: boolean;
    isVisual?: boolean;
}): string;
/**
 * remove line numbers from file path, ex:
 * `/foo:9` or `c:\bar:14:5`
 * @param   {string} filePath path to spec file
 * @returns {string}
 */
export declare function removeLineNumbers(filePath: string): string;
/**
 * does spec file path contain Cucumber's line number, ex
 * `/foo/bar:9` or `c:\bar\foo:14:5`
 * @param {string|string[]} spec
 */
export declare function isCucumberFeatureWithLineNumber(spec: string | string[]): boolean;
export declare function isCloudCapability(caps: Capabilities.Capabilities): boolean;
interface BackendConfigurations {
    port?: number;
    hostname?: string;
    user?: string;
    key?: string;
    protocol?: string;
    region?: string;
    headless?: boolean;
    path?: string;
    capabilities?: Capabilities.RemoteCapabilities | Capabilities.RemoteCapability;
}
/**
 * helper to detect the Selenium backend according to given capabilities
 */
export declare function detectBackend(options?: BackendConfigurations): {
    hostname: string | undefined;
    port: number | undefined;
    protocol: string | undefined;
    path: string | undefined;
};
/**
 * validates configurations based on default values
 * @param  {Object} defaults  object describing all allowed properties
 * @param  {Object} options   option to check against
 * @return {Object}           validated config enriched with default values
 */
export declare function validateConfig<T>(defaults: Options.Definition<T>, options: T, keysToKeep?: (keyof T)[]): T;
export interface ModuleRequireService {
    resolve(request: string, options?: {
        paths?: string[];
    }): string;
    require<T>(module: string): T;
}
export declare function loadAutoCompilers(autoCompileConfig: Options.AutoCompileConfig, requireService: ModuleRequireService): boolean;
export declare function loadTypeScriptCompiler(tsNodeOpts: RegisterOptions, requireService: ModuleRequireService): boolean;
export declare function loadBabelCompiler(babelOpts: {
    [key: string]: any;
}, requireService: ModuleRequireService): boolean;
export {};
//# sourceMappingURL=utils.d.ts.map